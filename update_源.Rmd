---
title: "update"
output: html_document
date: "2025-10-15"
---

```{r}
library(readxl)
library(dplyr)
library(stringr)
library(ggplot2)
library(scales)
library(plotly)
```


*导入历史数据*
```{r}
#输入认购（call）or 认沽（put）
type <- "call"

if (type == "call"){
  # 针对看涨期权
  load("call_data.RData")
} else if (type == "put") {
  # 针对看跌期权
  load("put_data.RData")
}
```


```{r}
# 封装一个读取和清洗函数
clean <- function(df) {
 
  # 把第二行第1列的数据放到第一行第1列
  df[1, 1] <- df[2, 1]
  # 删除第二行
  df <- df[-2, ]
  
  # 第一行设为列名
  colnames(df) <- as.character(unlist(df[1, ]))
  df <- df[-1, ]
  
  # 日期列转换（Excel 数值 → Date）
  df[[1]] <- as.Date(as.numeric(df[[1]]), origin = "1899-12-30")
  
   # 除第一列外的所有列都转换为 numeric
  if(ncol(df) > 1) {
    df[,-1] <- lapply(df[,-1], function(x) suppressWarnings(as.numeric(x)))
  }
  
  # 返回结果
  return(df)
}
```

*导入新数据*
```{r}
# 在文件开头定义配置，方便修改
file_path <- "中证1000认购update.xlsx"

# 一次性读取所有数据
close_price <- suppressMessages(read_excel(file_path, sheet = "收盘价", col_names = FALSE, skip = 2))
exercise_price <- suppressMessages(read_excel(file_path, sheet = "行权价格", col_names = FALSE, skip = 2))
target_close_price <- suppressMessages(read_excel(file_path, sheet = "标的收盘价", col_names = FALSE, skip = 2))
expire_date <- suppressMessages(read_excel(file_path, sheet = "到期日", col_names = FALSE, skip = 2))
volume <- suppressMessages(read_excel(file_path, sheet = "成交量", col_names = FALSE, skip = 2))
rf <- suppressMessages(read_excel(file_path, sheet = "无风险利率", col_names = FALSE, skip = 4))

ID <- data.frame(ID = t(close_price[1, -1]), stringsAsFactors = FALSE)

colnames(rf) <- c("时间", "无风险利率")
rf[,-1] <- lapply(rf[,-1], as.numeric)

close_price      <- clean(close_price)
exercise_price   <- clean(exercise_price)
target_close_price <- clean(target_close_price)
expire_date      <- clean(expire_date)
volume           <- clean(volume)

expire_date[-1] <- lapply(expire_date[-1], function(col) {
  as.Date(as.numeric(col), origin = "1899-12-30")
})

```


```{r}
if(!all(nrow(volume) == nrow(close_price), 
        nrow(volume) == nrow(target_close_price),
        nrow(volume) == nrow(expire_date),
        nrow(volume) == nrow(exercise_price))) {
  stop("所有数据的行数必须相同")
}

if(!all(ncol(volume)-1 == nrow(ID))) {  #第一列是时间
  stop("所有数据的ID必须相同")
}

```


*筛选缺失的交易日*
```{r}

latest_date <- as.Date(names(result_list_latest)[1])
today <- Sys.Date()

# 添加保护：如果 latest_date + 1 > today - 1，直接返回空序列
if (latest_date + 1 > today - 1) {
  diff_dates <- diff_dates <- close_price$时间[close_price$时间 != today]  
                                      # 那就重新检查除了今天的全部数据是否都在
} else {
  # 找出两者之间的日期（不包含这两个端点）
  #找出缺失的日期序列
  diff_dates <- seq(from = latest_date + 1, to = today - 1, by = "day")
  diff_dates <- diff_dates[diff_dates %in% volume$时间]
}

print(diff_dates)
```


*将expire_date，exercise_price写入ID*
```{r}
# 获取所有ID名称
ids <- as.character(ID[[1]])

# 为ID数据框添加到期日列和执行价格列
ID$Expire_Date <- as.Date(NA) # 创建到期日空列
ID$Exercise_Price <- NA_real_  # 创建执行价格空列，数值类型

# 合并填充到期日和执行价格
for(i in 1:length(ids)) {
  id <- ids[i]
  
  # 填充到期日
  if(id %in% colnames(expire_date)) {
    # 获取该ID的到期日（排除NA值）
    expiry <- na.omit(expire_date[[id]])
    if(length(expiry) > 0) {
      ID$Expire_Date[i] <- expiry[1] # 取第一个非NA值
    }
  }
  
  # 填充执行价格
  if(id %in% colnames(exercise_price)) {
    # 获取该ID的执行价格（排除NA值）
    exercise_price_vals <- na.omit(exercise_price[[id]])
    if(length(exercise_price_vals) > 0) {
      ID$Exercise_Price[i] <- exercise_price_vals[1] # 取第一个非NA值
    }
  }
}



```

*筛选需要日期的数据*
```{r}
# 创建结果列表
update_list <- list()

# 遍历每个日期，只处理 diff_dates
for(i in 1:nrow(volume)) {
  current_date <- volume$时间[i]
  
  # 只处理 diff_dates 中的日期
  if(current_date %in% diff_dates) {
    
    # 提取该日期的所有ID和对应的数据
    volume_values <- as.numeric(volume[i, -1]) # 排除第一列(日期)
    close_price_values <- as.numeric(close_price[i, -1])
    target_close_price_values <- as.numeric(target_close_price[i, -1])
    
    # 获取每个ID的到期日和行权价格
    expire_date_values <- ID$Expire_Date[match(ids, ID[[1]])]
    exercise_price_values <- ID$Exercise_Price[match(ids, ID[[1]])] #### 需不需要过滤掉到期日的数据
    
    # 创建数据框
    date_data <- data.frame(
      ID = ids,
      Volume = volume_values,
      Close_Price = close_price_values,
      Target_Close_Price = target_close_price_values,
      Expire_Date = expire_date_values,
      Exercise_Price = exercise_price_values,
      stringsAsFactors = FALSE
    )
    
    # 过滤掉成交量和收盘价都为0或NA的记录
    date_data <- subset(
      date_data,
      !( (is.na(Volume) | Volume == 0) & (is.na(Close_Price) | Close_Price == 0) )
    )
    
    # 如果有有效数据，添加到结果列表
    if(nrow(date_data) > 0 && !all(is.na(date_data[, -1]))) {
      update_list[[as.character(current_date)]] <- date_data
    }
  }
}

cat("处理完成，有效日期数量:", length(update_list), "\n")

```


*添加无风险利率rf，使其与日期匹配*
```{r}
# 统一类型
rf$时间 <- as.Date(rf$时间)

# 循环添加 rf 列
for(date_str in names(update_list)) {
  current_date <- as.Date(date_str)
  
  rf_row <- rf[rf$时间 == current_date, ]
  
  if(nrow(rf_row) > 0) {
    update_list[[date_str]]$rf <- rf_row$无风险利率[1]
  } else {
    warning(paste("在rf数据框中找不到日期:", current_date))
    update_list[[date_str]]$rf <- NA
  }
}

# 检查缺失
missing_rf_dates <- sapply(update_list, function(x) all(is.na(x$rf)))
if(any(missing_rf_dates)) {
  cat("以下日期缺少rf值:", toString(names(update_list)[missing_rf_dates]), "\n")
} else {
  cat("所有日期都成功添加了rf值\n")
}

```


*level 排序 实值期权\虚值期权*
```{r}
#在所有行权价大于平值期权的行权价的里面最小的那个设为1，第二小的设为2……，所有行权价小于平值期权的行权价的最大的那个设为-1，第二大的设为-2……允许并列

# 为每个日期的数据框添加 'level' 列
for(date_str in names(update_list)) {
  date_data <- update_list[[date_str]]
  
  # 计算行权价格与标的收盘价的差值
  date_data <- date_data %>%
    mutate(diff = abs(Target_Close_Price - Exercise_Price))
  
  # 找到与标的收盘价最接近的期权，标记为平值期权 (level = 0)
  min_diff_idx <- which.min(date_data$diff)
  date_data$level <- 0  # 默认值为0
  
  # 获取平值期权的行权价
  at_the_money_strike <- date_data$Exercise_Price[min_diff_idx]
  
  # 分离出大于平值期权的期权和小于平值期权的期权
  greater_than_atm <- date_data %>%
    filter(Exercise_Price > at_the_money_strike)
  less_than_atm <- date_data %>%
    filter(Exercise_Price < at_the_money_strike)
  
  # 保留平值期权
  at_the_money <- date_data %>%
    filter(Exercise_Price == at_the_money_strike)
  
  # 对大于平值期权的期权按行权价升序排序，并编号（并列）
  greater_than_atm <- greater_than_atm %>%
    arrange(Exercise_Price) %>%
    mutate(level = dense_rank(Exercise_Price))  # 使用dense_rank处理并列

  # 对小于平值期权的期权按行权价降序排序，并编号（并列）
  less_than_atm <- less_than_atm %>%
    arrange(desc(Exercise_Price)) %>%
    mutate(level = -dense_rank(desc(Exercise_Price)))  # 使用dense_rank处理并列并反向编号

  # 合并大于平值期权、小于平值期权以及平值期权
  date_data <- bind_rows(greater_than_atm, less_than_atm, at_the_money)
  
  # 更新 result_list 中的数据
  update_list[[date_str]] <- date_data
}

```


*对比行权价格与标的收盘价，确定当日的平值期权（可能有多个）*
```{r}
ID$Exercise_Price <- as.numeric(ID$Exercise_Price)
# 复制 update_list
At_the_money <- update_list  

# 遍历每个日期的数据，筛选最接近 at-the-money 的记录
At_the_money <- lapply(At_the_money, function(date_data) {
  # 计算差值（注意 exercise price 要除以 100）
  date_data <- date_data %>%
    mutate(diff = abs(Target_Close_Price - Exercise_Price))
  
  # 找到最小差值
  min_diff <- min(date_data$diff, na.rm = TRUE)
  
  # 保留最小差值的行（可能有多个）
  date_data <- date_data %>% filter(diff == min_diff)
  
  return(date_data)
})

```


*筛选掉临近到期日的合约*
```{r}
library(lubridate)

for (i in seq_along(At_the_money)) {
  current_date <- as.Date(names(At_the_money)[i])  # 提取表名的日期
  df <- At_the_money[[i]]
  
  # 确保到期日是日期类型
  df$Expire_Date <- as.Date(df$Expire_Date)
  
  # 筛选：到期日距离当前日期 > 1 天
  df <- df[df$Expire_Date - current_date > 1, ]
  
  # 回写
  At_the_money[[i]] <- df
}

```


*按每日最大成交量筛选主力合约*
```{r}
# 每日取平值期权成交量最大的合约
atm_max_vol <- lapply(At_the_money, function(date_data) {
  if(nrow(date_data) == 0) return(date_data[0, ])  # 空表处理
  
  max_vol <- max(date_data$Volume, na.rm = TRUE)
  date_data %>% filter(Volume == max_vol)
})

# 合并成总表，并去掉 diff
atm_max_vol_df <- bind_rows(atm_max_vol, .id = "Date") %>%
  select(-diff)
```


## *计算隐含波动率* 
```{r}
##########################  Black-Scholes 欧式看涨期权定价公式  ###################################

bs_call_price <- function(S, K, r, T, sigma) {
  d1 <- (log(S/K) + (r + 0.5*sigma^2)*T) / (sigma*sqrt(T))
  d2 <- d1 - sigma*sqrt(T)
  C <- S * pnorm(d1) - K * exp(-r*T) * pnorm(d2)
  return(C)
}

# 用市场价格反解隐含波动率
implied_vol_call <- function(C_market, S, K, r, T, 
                        sigma_lower=1e-6, sigma_upper=5) {
  # 检查输入有效性
  if (C_market <= max(S - K * exp(-r*T), 0) || C_market > S) {
    return(NA)  # 期权价格超出合理范围
  }
  
  tryCatch({
    uniroot(function(sigma) bs_call_price(S, K, r, T, sigma) - C_market, 
            lower=sigma_lower, upper=sigma_upper)$root
  }, error=function(e) {
    # 打印错误信息以便调试
    message(sprintf("IV calculation failed for S=%.4f, K=%.4f, T=%.4f, C=%.4f, r=%.4f: %s", 
                    S, K, T, C_market, r, e$message))
    NA
  })
}

# 计算隐含波动率
calculate_iv_call <- function(df) {
  df %>%
    mutate(
      # 确保日期列是正确的格式
      Date = as.Date(Date),
      Expire_Date = as.Date(Expire_Date),
      
      # 计算剩余时间（以年为单位）
      T = as.numeric(difftime(Expire_Date, Date, units = "days")) / 365,
      
      # 计算隐含波动率
      IV = mapply(
        function(c_market, S, K, r, T_val) {
          # 检查输入是否有效
          if (is.na(c_market) || is.na(S) || is.na(K) || is.na(r) || is.na(T_val) || 
              T_val <= 0 || S <= 0 || K <= 0 || c_market <= 0) {
            return(NA)
          }
          
          # 调用隐含波动率计算函数
          implied_vol_call(c_market, S, K, r/100, T_val)  # 注意：rf是百分比，需要除以100
        },
        Close_Price, Target_Close_Price, Exercise_Price, rf, T
      )
    ) %>%
    select(-T)  # 删除临时列
}




##########################  Black-Scholes 欧式看跌期权定价公式  ###################################

bs_put_price <- function(S, K, r, T, sigma) {
  d1 <- (log(S/K) + (r + 0.5*sigma^2)*T) / (sigma*sqrt(T))
  d2 <- d1 - sigma*sqrt(T)
  P <- K * exp(-r*T) * pnorm(-d2) - S * pnorm(-d1)
  return(P)
}

# 用市场价格反解隐含波动率（针对看跌期权）
implied_vol_put <- function(P_market, S, K, r, T, 
                            sigma_lower=1e-6, sigma_upper=5) {
  # 检查输入有效性
  if (P_market <= max(K * exp(-r*T) - S, 0) || P_market > S) {
    return(NA)  # 期权价格超出合理范围
  }
  
  tryCatch({
    uniroot(function(sigma) bs_put_price(S, K, r, T, sigma) - P_market, 
            lower=sigma_lower, upper=sigma_upper)$root
  }, error=function(e) {
    # 打印错误信息以便调试
    message(sprintf("IV calculation failed for S=%.4f, K=%.4f, T=%.4f, P=%.4f, r=%.4f: %s", 
                    S, K, T, P_market, r, e$message))
    NA
  })
}

# 计算隐含波动率（针对看跌期权）
calculate_iv_put <- function(df) {
  df %>%
    mutate(
      # 确保日期列是正确的格式
      Date = as.Date(Date),
      Expire_Date = as.Date(Expire_Date),
      
      # 计算剩余时间（以年为单位）
      T = as.numeric(difftime(Expire_Date, Date, units = "days")) / 365,
      
      # 计算隐含波动率
      IV = mapply(
        function(p_market, S, K, r, T_val) {
          # 检查输入是否有效
          if (is.na(p_market) || is.na(S) || is.na(K) || is.na(r) || is.na(T_val) || 
              T_val <= 0 || S <= 0 || K <= 0 || p_market <= 0) {
            return(NA)
          }
          
          # 调用隐含波动率计算函数
          implied_vol_put(p_market, S, K, r/100, T_val)  # 注意：rf是百分比，需要除以100
        },
        Close_Price, Target_Close_Price, Exercise_Price, rf, T
      )
    ) %>%
    select(-T)  # 删除临时列
}

```

```{r}
if (type == "call"){
  # 应用函数计算IV（针对看涨期权）
  atm_max_vol_df <- calculate_iv_call(atm_max_vol_df)
} else if (type == "put") {
  # 应用函数计算IV（针对看跌期权）
  atm_max_vol_df <- calculate_iv_put(atm_max_vol_df)
}

```


*合并新旧数据 list*
```{r}
# 1 提取日期名称
dates_A <- names(result_list_latest)
dates_B <- names(update_list)
all_dates <- sort(unique(c(dates_A, dates_B)), decreasing = TRUE)  # 降序排列

# 2 创建新 list
result_list <- list()

# 3 合并逻辑
for (d in all_dates) {
  if (d %in% dates_A & d %in% dates_B) {
    # 两边都有该日期 → 合并并去重
    df_A <- result_list_latest[[d]]
    df_B <- update_list[[d]]
    merged_df <- bind_rows(df_A, df_B) %>% distinct()
    result_list[[d]] <- merged_df
  } else if (d %in% dates_A) {
    # 仅在 A 中
    result_list[[d]] <- result_list_latest[[d]]
  } else {
    # 仅在 B 中
    result_list[[d]] <- update_list[[d]]
  }
}

# 4 去除每个数据框中的 NA 行
for (d in names(result_list)) {
  result_list[[d]] <- result_list[[d]] %>% filter(if_any(everything(), ~ !is.na(.)))
}

```

*合并新旧数据 df*
```{r}
# 合并新旧数据 df，并去重
# 1 提取日期
dates_A <- unique(atm_max_vol_df$Date)
dates_B <- unique(atm_max_vol_df_latest$Date)
all_dates <- sort(unique(c(dates_A, dates_B)), decreasing = TRUE)  # 降序排列

# 2 创建新数据框
result_df <- data.frame()

# 3 合并逻辑 - 与list合并相同的逻辑
for (d in all_dates) {
  if (d %in% dates_A & d %in% dates_B) {
    # 两边都有该日期 → 合并并去重
    df_A <- atm_max_vol_df[atm_max_vol_df$Date == d, ]
    df_B <- atm_max_vol_df_latest[atm_max_vol_df_latest$日期 == d, ]
    merged_df <- bind_rows(df_A, df_B) %>% distinct()
    result_df <- bind_rows(result_df, merged_df)
  } else if (d %in% dates_A) {
    # 仅在 A 中
    result_df <- bind_rows(result_df, atm_max_vol_df[atm_max_vol_df$Date == d, ])
  } else {
    # 仅在 B 中
    result_df <- bind_rows(result_df, atm_max_vol_df_latest[atm_max_vol_df_latest$Date == d, ])
  }
}

# 4 去除数据框中的 NA 行
result_df <- result_df %>% filter(if_any(everything(), ~ !is.na(.)))

```






*更新IV数据，保存更新后的往期数据*
```{r}
library(openxlsx)
result_list_latest <- result_list
atm_max_vol_df_latest <- result_df

if (type == "call"){
  # 针对看涨期权
  write.xlsx(atm_max_vol_df_latest, file = "IV_call_results.xlsx")
  save(result_list_latest, atm_max_vol_df_latest, file = "call_data.RData")
} else if (type == "put") {
  # 针对看跌期权
  write.xlsx(atm_max_vol_df_latest, file = "IV_put_results.xlsx")
  save(result_list_latest, atm_max_vol_df_latest, file = "put_data.RData")
}
```




*绘图*
```{r}
# 确保日期格式正确
atm_max_vol_df_latest$Date <- as.Date(atm_max_vol_df_latest$Date)

# 创建交互式图表
fig <- plot_ly(
  data = atm_max_vol_df_latest,
  x = ~Date,
  y = ~IV,
  type = 'scatter',
  mode = 'lines+markers',
  line = list(color = 'steelblue', width = 2),
  marker = list(size = 5, color = 'steelblue', opacity = 0.8),
  hovertemplate = paste(
    "<b>日期:</b> %{x}<br>",
    "<b>隐含波动率:</b> %{y:.2%}<extra></extra>"
  )
)

# 添加布局
fig <- fig %>%
  layout(
    title = list(
      text = "平值期权隐含波动率趋势",
      x = 0.5,
      font = list(size = 20, family = "Microsoft YaHei", color = "#333")
    ),
    xaxis = list(
      title = "日期",
      type = "date",
      tickformat = "%Y-%m-%d",
      rangeslider = list(visible = TRUE),  # ✅ 滑动条
      rangeselector = list(                # ✅ 快捷时间选择
        buttons = list(
          list(count = 7, label = "1周", step = "day", stepmode = "backward"),
          list(count = 1, label = "1月", step = "month", stepmode = "backward"),
          list(count = 3, label = "3月", step = "month", stepmode = "backward"),
          list(count = 6, label = "半年", step = "month", stepmode = "backward"),
          list(step = "all", label = "全部")
        )
      )
    ),
    yaxis = list(
      title = "隐含波动率",
      tickformat = ".1%",
      rangemode = "tozero"
    ),
    hovermode = "x unified",  # ✅ 悬停统一提示框
    plot_bgcolor = "#fafafa",
    paper_bgcolor = "#ffffff",
    margin = list(t = 70)
  )

# 显示图表
fig


```


*隐含波动率锥*
```{r}
#------------------------------
# 计算每个到期日的隐含波动率分布
#------------------------------
iv_cone <- atm_max_vol_df_latest %>%
  group_by(Expire_Date, Date) %>%
  summarise(mean_IV = mean(IV, na.rm = TRUE)) %>%
  group_by(Expire_Date) %>%
  summarise(
    p5 = quantile(mean_IV, 0.05, na.rm = TRUE),
    p25 = quantile(mean_IV, 0.25, na.rm = TRUE),
    median = quantile(mean_IV, 0.5, na.rm = TRUE),
    p75 = quantile(mean_IV, 0.75, na.rm = TRUE),
    p95 = quantile(mean_IV, 0.95, na.rm = TRUE)
  )

#------------------------------
# 提取最新日期的当前IV（用于红点标记）
#------------------------------
latest_date <- max(atm_max_vol_df_latest$Date, na.rm = TRUE)
current_iv <- atm_max_vol_df_latest %>%
  filter(Date == latest_date) %>%
  group_by(Expire_Date) %>%
  summarise(current_IV = mean(IV, na.rm = TRUE))

#------------------------------
# 绘制 Plotly 波动率锥 + 滑动条布局
#------------------------------
fig <- plot_ly() %>%
  # 灰色区间（5%-95%）
  add_trace(
    data = iv_cone,
    x = ~Expire_Date,
    y = ~p95,
    type = "scatter",
    mode = "lines",
    line = list(color = "lightgray"),
    name = "95分位",
    showlegend = FALSE
  ) %>%
  add_trace(
    data = iv_cone,
    x = ~Expire_Date,
    y = ~p5,
    type = "scatter",
    mode = "lines",
    fill = "tonexty",
    fillcolor = "rgba(211,211,211,0.3)",
    line = list(color = "lightgray"),
    name = "5分位",
    showlegend = TRUE
  ) %>%
  # 蓝色区间（25%-75%）
  add_trace(
    data = iv_cone,
    x = ~Expire_Date,
    y = ~p75,
    type = "scatter",
    mode = "lines",
    line = list(color = "skyblue"),
    name = "75分位",
    showlegend = FALSE
  ) %>%
  add_trace(
    data = iv_cone,
    x = ~Expire_Date,
    y = ~p25,
    type = "scatter",
    mode = "lines",
    fill = "tonexty",
    fillcolor = "rgba(135,206,235,0.4)",
    line = list(color = "skyblue"),
    name = "25分位",
    showlegend = TRUE
  ) %>%
  # 中位数
  add_trace(
    data = iv_cone,
    x = ~Expire_Date,
    y = ~median,
    type = "scatter",
    mode = "lines+markers",
    line = list(color = "steelblue", width = 3),
    marker = list(size = 5, color = "steelblue"),
    name = "中位数"
  ) %>%
  # 当前IV（红点）
  add_trace(
    data = current_iv,
    x = ~Expire_Date,
    y = ~current_IV,
    type = "scatter",
    mode = "markers+text",
    marker = list(size = 8, color = "red"),
    text = ~paste0("当前IV: ", round(current_IV, 4)),
    textposition = "top center",
    name = paste0("当前IV (", latest_date, ")")
  ) %>%
  layout(
    title = list(
      text = paste0("隐含波动率锥 - 截止日期：", latest_date),
      x = 0.8, 
      font = list(size = 20, family = "Microsoft YaHei", color = "#333")
    ),
    xaxis = list(
      title = "到期日",
      type = "date",
      tickformat = "%Y-%m-%d",
      rangeslider = list(visible = TRUE),
      rangeselector = list(
        buttons = list(
          list(count = 7, label = "1周", step = "day", stepmode = "backward"),
          list(count = 1, label = "1月", step = "month", stepmode = "backward"),
          list(count = 3, label = "3月", step = "month", stepmode = "backward"),
          list(count = 6, label = "半年", step = "month", stepmode = "backward"),
          list(step = "all", label = "全部")
        )
      )
    ),
    yaxis = list(
      title = "隐含波动率 (IV)",
      tickformat = ".1%",
      rangemode = "tozero"
    ),
    hovermode = "x unified",
    legend = list(orientation = "h", y = -0.2),
    plot_bgcolor = "#fafafa",
    paper_bgcolor = "#ffffff",
    margin = list(t = 70)
  )

#------------------------------
# 显示图形
#------------------------------
fig
```


*历史波动率锥*
```{r}
library(zoo)
library(plotly)

#----------------------------------------
# Step 1: 计算每日对数收益率
#----------------------------------------
price_df <- atm_max_vol_df_latest %>%
  arrange(Date) %>%
  mutate(Return = log(Target_Close_Price / lag(Target_Close_Price))) %>%
  filter(!is.na(Return))

#----------------------------------------
# Step 2: 定义滚动窗口
#----------------------------------------
window_list <- c(10, 20, 60, 120)

#----------------------------------------
# Step 3: 计算滚动年化历史波动率
#----------------------------------------
hv_data <- data.frame()
for (w in window_list) {
  hv_tmp <- price_df %>%
    mutate(
      HV = rollapply(Return, w, sd, fill = NA, align = "right") * sqrt(252),
      Window = w
    )
  hv_data <- bind_rows(hv_data, hv_tmp)
}

hv_data <- hv_data %>% filter(!is.na(HV))

#----------------------------------------
# Step 4: 静态分位数（用所有数据计算一次）
#----------------------------------------
hv_cone_static <- hv_data %>%
  group_by(Window) %>%
  summarise(
    p5 = quantile(HV, 0.05, na.rm = TRUE),
    p25 = quantile(HV, 0.25, na.rm = TRUE),
    median = quantile(HV, 0.5, na.rm = TRUE),
    p75 = quantile(HV, 0.75, na.rm = TRUE),
    p95 = quantile(HV, 0.95, na.rm = TRUE)
  )

#----------------------------------------
# Step 5: 动画红点数据
#----------------------------------------
hv_points <- hv_data %>%
  mutate(frame = as.character(Date)) %>%
  select(Window, HV, frame)

#----------------------------------------
# Step 6: 绘图优化版（避免滑条与图例重叠）
#----------------------------------------
p <- plot_ly() %>%
  # 灰色区间（5%-95%）
  add_trace(
    data = hv_cone_static,
    x = ~Window, y = ~p95,
    type = "scatter", mode = "lines",
    line = list(color = "lightgray"),
    name = "95分位", showlegend = FALSE
  ) %>%
  add_trace(
    data = hv_cone_static,
    x = ~Window, y = ~p5,
    type = "scatter", mode = "lines",
    fill = "tonexty", fillcolor = "rgba(211,211,211,0.3)",
    line = list(color = "lightgray"),
    name = "5-95分位区间", showlegend = TRUE
  ) %>%
  # 蓝色区间（25%-75%）
  add_trace(
    data = hv_cone_static,
    x = ~Window, y = ~p75,
    type = "scatter", mode = "lines",
    line = list(color = "skyblue"), name = "75分位", showlegend = FALSE
  ) %>%
  add_trace(
    data = hv_cone_static,
    x = ~Window, y = ~p25,
    type = "scatter", mode = "lines",
    fill = "tonexty", fillcolor = "rgba(135,206,235,0.4)",
    line = list(color = "skyblue"),
    name = "25-75分位区间", showlegend = TRUE
  ) %>%
  # 中位数线
  add_trace(
    data = hv_cone_static,
    x = ~Window, y = ~median,
    type = "scatter", mode = "lines+markers",
    line = list(color = "steelblue", width = 3),
    marker = list(size = 5, color = "steelblue"),
    name = "中位数"
  ) %>%
  # 红点动画
  add_trace(
    data = hv_points,
    x = ~Window, y = ~HV,
    frame = ~frame,
    type = "scatter", mode = "markers+text",
    marker = list(size = 8, color = "red"),
    text = ~paste0(Window, "天HV: ", round(HV * 100, 2), "%"),
    textposition = "top center",
    hovertemplate = paste0(
      "窗口: %{x}天<br>",
      "日期: %{frame}<br>",
      "HV: %{y:.2%}<br><extra></extra>"
    ),
    name = "目标日期HV"
  ) %>%
  layout(
    title = list(
      text = "历史波动率锥",
      x = 0.5,
      font = list(size = 16, family = "Microsoft YaHei", color = "#333")
    ),
    xaxis = list(
      title = "滚动窗口长度（天）",
      tickvals = window_list,
      ticktext = paste0(window_list, "天")
    ),
    yaxis = list(
      title = "年化历史波动率 (HV)",
      tickformat = ".1%",
      range = c(0, 1)
    ),
    hovermode = "x unified",
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.3   # ✅ 图例往下挪，防止重叠滑条
    ),
    plot_bgcolor = "#fafafa",
    paper_bgcolor = "#ffffff",
    margin = list(t = 80, b = 120) # ✅ 底部留出足够空间
  ) %>%
  animation_opts(
    frame = 100,
    transition = 0,
    easing = "linear",
    redraw = FALSE
  ) %>%
  animation_slider(
    currentvalue = list(prefix = "日期: ", font = list(color = "black")),
    pad = list(t = 60)  # 滑条与图体保持距离
  )

p

```

